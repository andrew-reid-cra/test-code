<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (25) -->
<title>Source code</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="source: package: ca.gc.cra.radar.config, record: CaptureConfig, enum: PersistenceQueueType">
<meta name="generator" content="javadoc/SourceToHTMLConverter">
<link rel="stylesheet" type="text/css" href="../../../../../../resource-files/stylesheet.css">
</head>
<body class="source-page">
<main role="main">
<div class="source-container">
<pre><span class="source-line-no">001</span><span id="line-1">package ca.gc.cra.radar.config;</span>
<span class="source-line-no">002</span><span id="line-2"></span>
<span class="source-line-no">003</span><span id="line-3">import ca.gc.cra.radar.validation.Net;</span>
<span class="source-line-no">004</span><span id="line-4">import ca.gc.cra.radar.validation.Numbers;</span>
<span class="source-line-no">005</span><span id="line-5">import ca.gc.cra.radar.validation.Strings;</span>
<span class="source-line-no">006</span><span id="line-6">import java.nio.file.InvalidPathException;</span>
<span class="source-line-no">007</span><span id="line-7">import java.nio.file.Path;</span>
<span class="source-line-no">008</span><span id="line-8">import java.util.HashMap;</span>
<span class="source-line-no">009</span><span id="line-9">import java.util.Locale;</span>
<span class="source-line-no">010</span><span id="line-10">import java.util.Map;</span>
<span class="source-line-no">011</span><span id="line-11">import java.util.Objects;</span>
<span class="source-line-no">012</span><span id="line-12"></span>
<span class="source-line-no">013</span><span id="line-13">/**</span>
<span class="source-line-no">014</span><span id="line-14"> * Configuration for the capture CLI, covering NIC selection, IO modes, and file rotation.</span>
<span class="source-line-no">015</span><span id="line-15"> *</span>
<span class="source-line-no">016</span><span id="line-16"> * @param iface network interface name to capture from</span>
<span class="source-line-no">017</span><span id="line-17"> * @param pcapFile offline capture file when provided</span>
<span class="source-line-no">018</span><span id="line-18"> * @param filter active BPF filter expression (sanitized)</span>
<span class="source-line-no">019</span><span id="line-19"> * @param customBpfEnabled {@code true} when a custom BPF expression was explicitly enabled</span>
<span class="source-line-no">020</span><span id="line-20"> * @param protocol capture protocol hint for default filtering</span>
<span class="source-line-no">021</span><span id="line-21"> * @param snaplen libpcap snap length in bytes</span>
<span class="source-line-no">022</span><span id="line-22"> * @param bufferBytes capture buffer size in bytes</span>
<span class="source-line-no">023</span><span id="line-23"> * @param timeoutMillis polling timeout in milliseconds</span>
<span class="source-line-no">024</span><span id="line-24"> * @param promiscuous whether to enable promiscuous mode</span>
<span class="source-line-no">025</span><span id="line-25"> * @param immediate whether to request immediate mode from libpcap</span>
<span class="source-line-no">026</span><span id="line-26"> * @param outputDirectory directory for persisted segment files in file mode</span>
<span class="source-line-no">027</span><span id="line-27"> * @param fileBase filename prefix for rotated segment files</span>
<span class="source-line-no">028</span><span id="line-28"> * @param rollMiB maximum file size before rotation (mebibytes)</span>
<span class="source-line-no">029</span><span id="line-29"> * @param httpOutputDirectory directory for HTTP poster artifacts</span>
<span class="source-line-no">030</span><span id="line-30"> * @param tn3270OutputDirectory directory for TN3270 poster artifacts</span>
<span class="source-line-no">031</span><span id="line-31"> * @param ioMode capture persistence mode ({@link IoMode#FILE} or {@link IoMode#KAFKA})</span>
<span class="source-line-no">032</span><span id="line-32"> * @param kafkaBootstrap Kafka bootstrap servers (required for Kafka mode)</span>
<span class="source-line-no">033</span><span id="line-33"> * @param kafkaTopicSegments Kafka topic for segments in Kafka mode</span>
<span class="source-line-no">034</span><span id="line-34"> * @param persistenceWorkers number of persistence workers for live processing</span>
<span class="source-line-no">035</span><span id="line-35"> * @param persistenceQueueCapacity capacity of the live persistence queue</span>
<span class="source-line-no">036</span><span id="line-36"> * @param persistenceQueueType queue implementation used for live persistence hand-off</span>
<span class="source-line-no">037</span><span id="line-37"> * @since RADAR 0.1-doc</span>
<span class="source-line-no">038</span><span id="line-38"> */</span>
<span class="source-line-no">039</span><span id="line-39">public record CaptureConfig(</span>
<span class="source-line-no">040</span><span id="line-40">    String iface,</span>
<span class="source-line-no">041</span><span id="line-41">    Path pcapFile,</span>
<span class="source-line-no">042</span><span id="line-42">    String filter,</span>
<span class="source-line-no">043</span><span id="line-43">    boolean customBpfEnabled,</span>
<span class="source-line-no">044</span><span id="line-44">    CaptureProtocol protocol,</span>
<span class="source-line-no">045</span><span id="line-45">    int snaplen,</span>
<span class="source-line-no">046</span><span id="line-46">    int bufferBytes,</span>
<span class="source-line-no">047</span><span id="line-47">    int timeoutMillis,</span>
<span class="source-line-no">048</span><span id="line-48">    boolean promiscuous,</span>
<span class="source-line-no">049</span><span id="line-49">    boolean immediate,</span>
<span class="source-line-no">050</span><span id="line-50">    Path outputDirectory,</span>
<span class="source-line-no">051</span><span id="line-51">    String fileBase,</span>
<span class="source-line-no">052</span><span id="line-52">    int rollMiB,</span>
<span class="source-line-no">053</span><span id="line-53">    Path httpOutputDirectory,</span>
<span class="source-line-no">054</span><span id="line-54">    Path tn3270OutputDirectory,</span>
<span class="source-line-no">055</span><span id="line-55">    IoMode ioMode,</span>
<span class="source-line-no">056</span><span id="line-56">    String kafkaBootstrap,</span>
<span class="source-line-no">057</span><span id="line-57">    String kafkaTopicSegments,</span>
<span class="source-line-no">058</span><span id="line-58">    int persistenceWorkers,</span>
<span class="source-line-no">059</span><span id="line-59">    int persistenceQueueCapacity,</span>
<span class="source-line-no">060</span><span id="line-60">    PersistenceQueueType persistenceQueueType) {</span>
<span class="source-line-no">061</span><span id="line-61"></span>
<span class="source-line-no">062</span><span id="line-62">  private static final String DEFAULT_SAFE_BPF = CaptureProtocol.GENERIC.defaultFilter();</span>
<span class="source-line-no">063</span><span id="line-63">  private static final int DEFAULT_SNAPLEN = 65_535;</span>
<span class="source-line-no">064</span><span id="line-64">  private static final int DEFAULT_BUFFER_MIB = 256;</span>
<span class="source-line-no">065</span><span id="line-65">  private static final int DEFAULT_TIMEOUT_MILLIS = 1_000;</span>
<span class="source-line-no">066</span><span id="line-66">  private static final int DEFAULT_ROLL_MIB = 512;</span>
<span class="source-line-no">067</span><span id="line-67">  private static final int MIN_SNAPLEN = 64;</span>
<span class="source-line-no">068</span><span id="line-68">  private static final int MAX_SNAPLEN = 262_144;</span>
<span class="source-line-no">069</span><span id="line-69">  private static final int MIN_BUFFER_MIB = 4;</span>
<span class="source-line-no">070</span><span id="line-70">  private static final int MAX_BUFFER_MIB = 4_096;</span>
<span class="source-line-no">071</span><span id="line-71">  private static final int MIN_TIMEOUT_MILLIS = 0;</span>
<span class="source-line-no">072</span><span id="line-72">  private static final int MAX_TIMEOUT_MILLIS = 60_000;</span>
<span class="source-line-no">073</span><span id="line-73">  private static final int MIN_ROLL_MIB = 8;</span>
<span class="source-line-no">074</span><span id="line-74">  private static final int MAX_ROLL_MIB = 10_240;</span>
<span class="source-line-no">075</span><span id="line-75">  private static final int MAX_BPF_LENGTH = 1_024;</span>
<span class="source-line-no">076</span><span id="line-76">  private static final int MIN_PERSIST_WORKERS = 1;</span>
<span class="source-line-no">077</span><span id="line-77">  private static final int MAX_PERSIST_WORKERS = 32;</span>
<span class="source-line-no">078</span><span id="line-78">  private static final int MAX_QUEUE_CAPACITY = 65_536;</span>
<span class="source-line-no">079</span><span id="line-79"></span>
<span class="source-line-no">080</span><span id="line-80">  /**</span>
<span class="source-line-no">081</span><span id="line-81">   * Validates capture configuration values.</span>
<span class="source-line-no">082</span><span id="line-82">   *</span>
<span class="source-line-no">083</span><span id="line-83">   * @since RADAR 0.1-doc</span>
<span class="source-line-no">084</span><span id="line-84">   */</span>
<span class="source-line-no">085</span><span id="line-85">  public CaptureConfig {</span>
<span class="source-line-no">086</span><span id="line-86">    boolean offline = pcapFile != null;</span>
<span class="source-line-no">087</span><span id="line-87">    if (offline) {</span>
<span class="source-line-no">088</span><span id="line-88">      pcapFile = normalizePath("pcapFile", pcapFile);</span>
<span class="source-line-no">089</span><span id="line-89">    }</span>
<span class="source-line-no">090</span><span id="line-90">    if (!offline) {</span>
<span class="source-line-no">091</span><span id="line-91">      iface = Strings.requireNonBlank("iface", iface);</span>
<span class="source-line-no">092</span><span id="line-92">    } else if (iface == null || iface.isBlank()) {</span>
<span class="source-line-no">093</span><span id="line-93">      iface = "pcap:" + pcapFile.getFileName();</span>
<span class="source-line-no">094</span><span id="line-94">    } else {</span>
<span class="source-line-no">095</span><span id="line-95">      iface = Strings.requireNonBlank("iface", iface);</span>
<span class="source-line-no">096</span><span id="line-96">    }</span>
<span class="source-line-no">097</span><span id="line-97">    protocol = Objects.requireNonNullElse(protocol, CaptureProtocol.GENERIC);</span>
<span class="source-line-no">098</span><span id="line-98">    filter = Strings.requirePrintableAscii("bpf", filter, MAX_BPF_LENGTH);</span>
<span class="source-line-no">099</span><span id="line-99">    outputDirectory = normalizePath("outputDirectory", outputDirectory);</span>
<span class="source-line-no">100</span><span id="line-100">    httpOutputDirectory = normalizePath("httpOutputDirectory", httpOutputDirectory);</span>
<span class="source-line-no">101</span><span id="line-101">    tn3270OutputDirectory = normalizePath("tn3270OutputDirectory", tn3270OutputDirectory);</span>
<span class="source-line-no">102</span><span id="line-102">    fileBase = Strings.requireNonBlank("fileBase", fileBase);</span>
<span class="source-line-no">103</span><span id="line-103">    Numbers.requireRange("snaplen", snaplen, MIN_SNAPLEN, MAX_SNAPLEN);</span>
<span class="source-line-no">104</span><span id="line-104">    Numbers.requireRange(</span>
<span class="source-line-no">105</span><span id="line-105">        "bufferBytes",</span>
<span class="source-line-no">106</span><span id="line-106">        bufferBytes,</span>
<span class="source-line-no">107</span><span id="line-107">        MIN_BUFFER_MIB * 1_024L * 1_024L,</span>
<span class="source-line-no">108</span><span id="line-108">        MAX_BUFFER_MIB * 1_024L * 1_024L);</span>
<span class="source-line-no">109</span><span id="line-109">    Numbers.requireRange("timeoutMillis", timeoutMillis, MIN_TIMEOUT_MILLIS, MAX_TIMEOUT_MILLIS);</span>
<span class="source-line-no">110</span><span id="line-110">    Numbers.requireRange("rollMiB", rollMiB, MIN_ROLL_MIB, MAX_ROLL_MIB);</span>
<span class="source-line-no">111</span><span id="line-111">    Numbers.requireRange("persistenceWorkers", persistenceWorkers, MIN_PERSIST_WORKERS, MAX_PERSIST_WORKERS);</span>
<span class="source-line-no">112</span><span id="line-112">    Numbers.requireRange(</span>
<span class="source-line-no">113</span><span id="line-113">        "persistenceQueueCapacity",</span>
<span class="source-line-no">114</span><span id="line-114">        persistenceQueueCapacity,</span>
<span class="source-line-no">115</span><span id="line-115">        persistenceWorkers,</span>
<span class="source-line-no">116</span><span id="line-116">        MAX_QUEUE_CAPACITY);</span>
<span class="source-line-no">117</span><span id="line-117">    ioMode = Objects.requireNonNullElse(ioMode, IoMode.FILE);</span>
<span class="source-line-no">118</span><span id="line-118">    persistenceQueueType = Objects.requireNonNullElse(persistenceQueueType, PersistenceQueueType.ARRAY);</span>
<span class="source-line-no">119</span><span id="line-119">    if (kafkaBootstrap != null &amp;&amp; !kafkaBootstrap.isBlank()) {</span>
<span class="source-line-no">120</span><span id="line-120">      kafkaBootstrap = Net.validateHostPort(kafkaBootstrap);</span>
<span class="source-line-no">121</span><span id="line-121">    } else {</span>
<span class="source-line-no">122</span><span id="line-122">      kafkaBootstrap = null;</span>
<span class="source-line-no">123</span><span id="line-123">    }</span>
<span class="source-line-no">124</span><span id="line-124">    if (kafkaTopicSegments != null) {</span>
<span class="source-line-no">125</span><span id="line-125">      kafkaTopicSegments = Strings.sanitizeTopic("kafkaTopicSegments", kafkaTopicSegments);</span>
<span class="source-line-no">126</span><span id="line-126">    }</span>
<span class="source-line-no">127</span><span id="line-127">    if (ioMode == IoMode.KAFKA) {</span>
<span class="source-line-no">128</span><span id="line-128">      if (kafkaBootstrap == null) {</span>
<span class="source-line-no">129</span><span id="line-129">        throw new IllegalArgumentException("kafkaBootstrap is required when ioMode=KAFKA");</span>
<span class="source-line-no">130</span><span id="line-130">      }</span>
<span class="source-line-no">131</span><span id="line-131">      if (kafkaTopicSegments == null || kafkaTopicSegments.isBlank()) {</span>
<span class="source-line-no">132</span><span id="line-132">        throw new IllegalArgumentException("kafkaTopicSegments is required when ioMode=KAFKA");</span>
<span class="source-line-no">133</span><span id="line-133">      }</span>
<span class="source-line-no">134</span><span id="line-134">    }</span>
<span class="source-line-no">135</span><span id="line-135">  }</span>
<span class="source-line-no">136</span><span id="line-136"></span>
<span class="source-line-no">137</span><span id="line-137">  /**</span>
<span class="source-line-no">138</span><span id="line-138">   * Provides default capture settings that assume local file output with conservative tuning.</span>
<span class="source-line-no">139</span><span id="line-139">   *</span>
<span class="source-line-no">140</span><span id="line-140">   * @return default configuration</span>
<span class="source-line-no">141</span><span id="line-141">   * @since RADAR 0.1-doc</span>
<span class="source-line-no">142</span><span id="line-142">   */</span>
<span class="source-line-no">143</span><span id="line-143">  public static CaptureConfig defaults() {</span>
<span class="source-line-no">144</span><span id="line-144">    Path base = defaultBaseDirectory();</span>
<span class="source-line-no">145</span><span id="line-145">    int processors = Math.max(1, Runtime.getRuntime().availableProcessors());</span>
<span class="source-line-no">146</span><span id="line-146">    int defaultWorkers = Math.min(4, Math.max(1, processors / 2));</span>
<span class="source-line-no">147</span><span id="line-147">    int defaultQueueCapacity = defaultWorkers * 64;</span>
<span class="source-line-no">148</span><span id="line-148">    return new CaptureConfig(</span>
<span class="source-line-no">149</span><span id="line-149">        "eth0",</span>
<span class="source-line-no">150</span><span id="line-150">        null,</span>
<span class="source-line-no">151</span><span id="line-151">        DEFAULT_SAFE_BPF,</span>
<span class="source-line-no">152</span><span id="line-152">        false,</span>
<span class="source-line-no">153</span><span id="line-153">        CaptureProtocol.GENERIC,</span>
<span class="source-line-no">154</span><span id="line-154">        DEFAULT_SNAPLEN,</span>
<span class="source-line-no">155</span><span id="line-155">        DEFAULT_BUFFER_MIB * 1_024 * 1_024,</span>
<span class="source-line-no">156</span><span id="line-156">        DEFAULT_TIMEOUT_MILLIS,</span>
<span class="source-line-no">157</span><span id="line-157">        false,</span>
<span class="source-line-no">158</span><span id="line-158">        false,</span>
<span class="source-line-no">159</span><span id="line-159">        base.resolve("capture").resolve("segments"),</span>
<span class="source-line-no">160</span><span id="line-160">        "segments",</span>
<span class="source-line-no">161</span><span id="line-161">        DEFAULT_ROLL_MIB,</span>
<span class="source-line-no">162</span><span id="line-162">        base.resolve("capture").resolve("http"),</span>
<span class="source-line-no">163</span><span id="line-163">        base.resolve("capture").resolve("tn3270"),</span>
<span class="source-line-no">164</span><span id="line-164">        IoMode.FILE,</span>
<span class="source-line-no">165</span><span id="line-165">        null,</span>
<span class="source-line-no">166</span><span id="line-166">        "radar.segments",</span>
<span class="source-line-no">167</span><span id="line-167">        defaultWorkers,</span>
<span class="source-line-no">168</span><span id="line-168">        defaultQueueCapacity,</span>
<span class="source-line-no">169</span><span id="line-169">        PersistenceQueueType.ARRAY);</span>
<span class="source-line-no">170</span><span id="line-170">  }</span>
<span class="source-line-no">171</span><span id="line-171"></span>
<span class="source-line-no">172</span><span id="line-172">  /**</span>
<span class="source-line-no">173</span><span id="line-173">   * Parses CLI-style {@code key=value} arguments into a configuration.</span>
<span class="source-line-no">174</span><span id="line-174">   *</span>
<span class="source-line-no">175</span><span id="line-175">   * @param args CLI arguments; may be {@code null}</span>
<span class="source-line-no">176</span><span id="line-176">   * @return parsed configuration</span>
<span class="source-line-no">177</span><span id="line-177">   * @throws IllegalArgumentException when required values are missing or invalid</span>
<span class="source-line-no">178</span><span id="line-178">   * @since RADAR 0.1-doc</span>
<span class="source-line-no">179</span><span id="line-179">   */</span>
<span class="source-line-no">180</span><span id="line-180">  public static CaptureConfig fromMap(Map&lt;String, String&gt; args) {</span>
<span class="source-line-no">181</span><span id="line-181">    Map&lt;String, String&gt; kv = args == null ? Map.of() : new HashMap&lt;&gt;(args);</span>
<span class="source-line-no">182</span><span id="line-182">    CaptureConfig defaults = defaults();</span>
<span class="source-line-no">183</span><span id="line-183"></span>
<span class="source-line-no">184</span><span id="line-184">    Path pcapFile = parseOptionalPath("pcapFile", kv.get("pcapFile")).orElse(null);</span>
<span class="source-line-no">185</span><span id="line-185"></span>
<span class="source-line-no">186</span><span id="line-186">    String ifaceRaw = kv.get("iface");</span>
<span class="source-line-no">187</span><span id="line-187">    String iface;</span>
<span class="source-line-no">188</span><span id="line-188">    if (pcapFile == null) {</span>
<span class="source-line-no">189</span><span id="line-189">      String fallbackIface = (ifaceRaw == null || ifaceRaw.isBlank()) ? defaults.iface() : ifaceRaw;</span>
<span class="source-line-no">190</span><span id="line-190">      iface = Strings.requireNonBlank("iface", fallbackIface);</span>
<span class="source-line-no">191</span><span id="line-191">    } else if (ifaceRaw != null &amp;&amp; !ifaceRaw.isBlank()) {</span>
<span class="source-line-no">192</span><span id="line-192">      iface = Strings.requireNonBlank("iface", ifaceRaw);</span>
<span class="source-line-no">193</span><span id="line-193">    } else {</span>
<span class="source-line-no">194</span><span id="line-194">      iface = null;</span>
<span class="source-line-no">195</span><span id="line-195">    }</span>
<span class="source-line-no">196</span><span id="line-196"></span>
<span class="source-line-no">197</span><span id="line-197">    boolean bpfAcknowledged = parseBoolean(kv.get("enableBpf"), false);</span>
<span class="source-line-no">198</span><span id="line-198">    CaptureProtocol protocol = CaptureProtocol.fromString(kv.get("protocol"));</span>
<span class="source-line-no">199</span><span id="line-199">    String filter = protocol.defaultFilter();</span>
<span class="source-line-no">200</span><span id="line-200">    boolean customBpf = false;</span>
<span class="source-line-no">201</span><span id="line-201">    String rawFilter = kv.get("bpf");</span>
<span class="source-line-no">202</span><span id="line-202">    if (rawFilter != null &amp;&amp; !rawFilter.isBlank()) {</span>
<span class="source-line-no">203</span><span id="line-203">      if (!bpfAcknowledged) {</span>
<span class="source-line-no">204</span><span id="line-204">        throw new IllegalArgumentException("bpf requires --enable-bpf acknowledgement");</span>
<span class="source-line-no">205</span><span id="line-205">      }</span>
<span class="source-line-no">206</span><span id="line-206">      filter = Strings.requirePrintableAscii("bpf", rawFilter, MAX_BPF_LENGTH);</span>
<span class="source-line-no">207</span><span id="line-207">      denyDangerousBpf(filter);</span>
<span class="source-line-no">208</span><span id="line-208">      customBpf = true;</span>
<span class="source-line-no">209</span><span id="line-209">    }</span>
<span class="source-line-no">210</span><span id="line-210"></span>
<span class="source-line-no">211</span><span id="line-211">    int snap;</span>
<span class="source-line-no">212</span><span id="line-212">    if (kv.get("snaplen") != null &amp;&amp; !kv.get("snaplen").isBlank()) {</span>
<span class="source-line-no">213</span><span id="line-213">      snap = parseBoundedInt(kv, "snaplen", defaults.snaplen(), MIN_SNAPLEN, MAX_SNAPLEN);</span>
<span class="source-line-no">214</span><span id="line-214">    } else {</span>
<span class="source-line-no">215</span><span id="line-215">      snap = parseBoundedInt(kv, "snap", defaults.snaplen(), MIN_SNAPLEN, MAX_SNAPLEN);</span>
<span class="source-line-no">216</span><span id="line-216">    }</span>
<span class="source-line-no">217</span><span id="line-217">    int bufMib = parseBoundedInt(kv, "bufmb", defaults.bufferBytes() / (1_024 * 1_024), MIN_BUFFER_MIB, MAX_BUFFER_MIB);</span>
<span class="source-line-no">218</span><span id="line-218">    int bufferBytes = Math.toIntExact(bufMib * 1_024L * 1_024L);</span>
<span class="source-line-no">219</span><span id="line-219">    int timeout = parseBoundedInt(kv, "timeout", defaults.timeoutMillis(), MIN_TIMEOUT_MILLIS, MAX_TIMEOUT_MILLIS);</span>
<span class="source-line-no">220</span><span id="line-220">    boolean promisc = parseBoolean(kv.get("promisc"), defaults.promiscuous());</span>
<span class="source-line-no">221</span><span id="line-221">    boolean immediate = parseBoolean(kv.get("immediate"), defaults.immediate());</span>
<span class="source-line-no">222</span><span id="line-222"></span>
<span class="source-line-no">223</span><span id="line-223">    String outRaw = firstNonBlank(kv, "out", "segmentsOut");</span>
<span class="source-line-no">224</span><span id="line-224">    Path outputDir = defaults.outputDirectory();</span>
<span class="source-line-no">225</span><span id="line-225">    IoMode ioMode = parseIoMode(kv.get("ioMode"), defaults.ioMode());</span>
<span class="source-line-no">226</span><span id="line-226">    String kafkaTopicSegments = defaults.kafkaTopicSegments();</span>
<span class="source-line-no">227</span><span id="line-227">    if (outRaw != null) {</span>
<span class="source-line-no">228</span><span id="line-228">      if (outRaw.startsWith("kafka:")) {</span>
<span class="source-line-no">229</span><span id="line-229">        ioMode = IoMode.KAFKA;</span>
<span class="source-line-no">230</span><span id="line-230">        kafkaTopicSegments = Strings.sanitizeTopic("kafkaTopicSegments", outRaw.substring("kafka:".length()));</span>
<span class="source-line-no">231</span><span id="line-231">      } else {</span>
<span class="source-line-no">232</span><span id="line-232">        outputDir = parsePath("out", outRaw);</span>
<span class="source-line-no">233</span><span id="line-233">      }</span>
<span class="source-line-no">234</span><span id="line-234">    }</span>
<span class="source-line-no">235</span><span id="line-235"></span>
<span class="source-line-no">236</span><span id="line-236">    String fileBase = Strings.requireNonBlank("fileBase", kv.getOrDefault("fileBase", defaults.fileBase()));</span>
<span class="source-line-no">237</span><span id="line-237">    int rollMiB = parseBoundedInt(kv, "rollMiB", defaults.rollMiB(), MIN_ROLL_MIB, MAX_ROLL_MIB);</span>
<span class="source-line-no">238</span><span id="line-238"></span>
<span class="source-line-no">239</span><span id="line-239">    Path httpOut = parseOptionalPath("httpOut", firstNonBlank(kv, "httpOut", "--httpOut"))</span>
<span class="source-line-no">240</span><span id="line-240">        .orElse(defaults.httpOutputDirectory());</span>
<span class="source-line-no">241</span><span id="line-241">    Path tnOut = parseOptionalPath("tnOut", firstNonBlank(kv, "tnOut", "--tnOut"))</span>
<span class="source-line-no">242</span><span id="line-242">        .orElse(defaults.tn3270OutputDirectory());</span>
<span class="source-line-no">243</span><span id="line-243"></span>
<span class="source-line-no">244</span><span id="line-244">    String kafkaBootstrapRaw = kv.get("kafkaBootstrap");</span>
<span class="source-line-no">245</span><span id="line-245">    String kafkaBootstrap = kafkaBootstrapRaw == null || kafkaBootstrapRaw.isBlank()</span>
<span class="source-line-no">246</span><span id="line-246">        ? null</span>
<span class="source-line-no">247</span><span id="line-247">        : Net.validateHostPort(kafkaBootstrapRaw);</span>
<span class="source-line-no">248</span><span id="line-248">    String kafkaTopicOverride = kv.get("kafkaTopicSegments");</span>
<span class="source-line-no">249</span><span id="line-249">    if (kafkaTopicOverride != null &amp;&amp; !kafkaTopicOverride.isBlank()) {</span>
<span class="source-line-no">250</span><span id="line-250">      kafkaTopicSegments = Strings.sanitizeTopic("kafkaTopicSegments", kafkaTopicOverride);</span>
<span class="source-line-no">251</span><span id="line-251">    }</span>
<span class="source-line-no">252</span><span id="line-252"></span>
<span class="source-line-no">253</span><span id="line-253">    int persistenceWorkers = parseBoundedInt(</span>
<span class="source-line-no">254</span><span id="line-254">        kv,</span>
<span class="source-line-no">255</span><span id="line-255">        "persistWorkers",</span>
<span class="source-line-no">256</span><span id="line-256">        defaults.persistenceWorkers(),</span>
<span class="source-line-no">257</span><span id="line-257">        MIN_PERSIST_WORKERS,</span>
<span class="source-line-no">258</span><span id="line-258">        MAX_PERSIST_WORKERS);</span>
<span class="source-line-no">259</span><span id="line-259">    int persistenceQueueCapacity = parseBoundedInt(</span>
<span class="source-line-no">260</span><span id="line-260">        kv,</span>
<span class="source-line-no">261</span><span id="line-261">        "persistQueueCapacity",</span>
<span class="source-line-no">262</span><span id="line-262">        defaults.persistenceQueueCapacity(),</span>
<span class="source-line-no">263</span><span id="line-263">        persistenceWorkers,</span>
<span class="source-line-no">264</span><span id="line-264">        MAX_QUEUE_CAPACITY);</span>
<span class="source-line-no">265</span><span id="line-265">    PersistenceQueueType persistenceQueueType =</span>
<span class="source-line-no">266</span><span id="line-266">        parsePersistenceQueueType(kv.get("persistQueueType"), defaults.persistenceQueueType());</span>
<span class="source-line-no">267</span><span id="line-267"></span>
<span class="source-line-no">268</span><span id="line-268">    return new CaptureConfig(</span>
<span class="source-line-no">269</span><span id="line-269">        iface,</span>
<span class="source-line-no">270</span><span id="line-270">        pcapFile,</span>
<span class="source-line-no">271</span><span id="line-271">        filter,</span>
<span class="source-line-no">272</span><span id="line-272">        customBpf,</span>
<span class="source-line-no">273</span><span id="line-273">        protocol,</span>
<span class="source-line-no">274</span><span id="line-274">        snap,</span>
<span class="source-line-no">275</span><span id="line-275">        bufferBytes,</span>
<span class="source-line-no">276</span><span id="line-276">        timeout,</span>
<span class="source-line-no">277</span><span id="line-277">        promisc,</span>
<span class="source-line-no">278</span><span id="line-278">        immediate,</span>
<span class="source-line-no">279</span><span id="line-279">        outputDir,</span>
<span class="source-line-no">280</span><span id="line-280">        fileBase,</span>
<span class="source-line-no">281</span><span id="line-281">        rollMiB,</span>
<span class="source-line-no">282</span><span id="line-282">        httpOut,</span>
<span class="source-line-no">283</span><span id="line-283">        tnOut,</span>
<span class="source-line-no">284</span><span id="line-284">        ioMode,</span>
<span class="source-line-no">285</span><span id="line-285">        kafkaBootstrap,</span>
<span class="source-line-no">286</span><span id="line-286">        kafkaTopicSegments,</span>
<span class="source-line-no">287</span><span id="line-287">        persistenceWorkers,</span>
<span class="source-line-no">288</span><span id="line-288">        persistenceQueueCapacity,</span>
<span class="source-line-no">289</span><span id="line-289">        persistenceQueueType);</span>
<span class="source-line-no">290</span><span id="line-290">  }</span>
<span class="source-line-no">291</span><span id="line-291"></span>
<span class="source-line-no">292</span><span id="line-292">  /**</span>
<span class="source-line-no">293</span><span id="line-293">   * Parses CLI-style {@code key=value} arguments into a configuration (legacy helper).</span>
<span class="source-line-no">294</span><span id="line-294">   *</span>
<span class="source-line-no">295</span><span id="line-295">   * @param args CLI arguments array</span>
<span class="source-line-no">296</span><span id="line-296">   * @return parsed configuration</span>
<span class="source-line-no">297</span><span id="line-297">   * @throws IllegalArgumentException if parsing fails</span>
<span class="source-line-no">298</span><span id="line-298">   * @deprecated since RADAR 0.1.1; prefer {@link #fromMap(Map)} fed by {@code CliArgsParser.toMap(args)}.</span>
<span class="source-line-no">299</span><span id="line-299">   */</span>
<span class="source-line-no">300</span><span id="line-300">  @Deprecated(since = "0.1.1", forRemoval = true)</span>
<span class="source-line-no">301</span><span id="line-301">  public static CaptureConfig fromArgs(String[] args) {</span>
<span class="source-line-no">302</span><span id="line-302">    Map&lt;String, String&gt; kv = new HashMap&lt;&gt;();</span>
<span class="source-line-no">303</span><span id="line-303">    if (args != null) {</span>
<span class="source-line-no">304</span><span id="line-304">      for (String arg : args) {</span>
<span class="source-line-no">305</span><span id="line-305">        if (arg == null || arg.isBlank()) {</span>
<span class="source-line-no">306</span><span id="line-306">          continue;</span>
<span class="source-line-no">307</span><span id="line-307">        }</span>
<span class="source-line-no">308</span><span id="line-308">        String[] parts = arg.split("=", 2);</span>
<span class="source-line-no">309</span><span id="line-309">        String key = parts[0];</span>
<span class="source-line-no">310</span><span id="line-310">        String value = parts.length &gt; 1 ? parts[1] : "";</span>
<span class="source-line-no">311</span><span id="line-311">        kv.put(key, value);</span>
<span class="source-line-no">312</span><span id="line-312">      }</span>
<span class="source-line-no">313</span><span id="line-313">    }</span>
<span class="source-line-no">314</span><span id="line-314">    return fromMap(kv);</span>
<span class="source-line-no">315</span><span id="line-315">  }</span>
<span class="source-line-no">316</span><span id="line-316"></span>
<span class="source-line-no">317</span><span id="line-317">  private static IoMode parseIoMode(String value, IoMode fallback) {</span>
<span class="source-line-no">318</span><span id="line-318">    if (value == null || value.isBlank()) {</span>
<span class="source-line-no">319</span><span id="line-319">      return fallback;</span>
<span class="source-line-no">320</span><span id="line-320">    }</span>
<span class="source-line-no">321</span><span id="line-321">    return IoMode.fromString(value.trim());</span>
<span class="source-line-no">322</span><span id="line-322">  }</span>
<span class="source-line-no">323</span><span id="line-323"></span>
<span class="source-line-no">324</span><span id="line-324">  private static PersistenceQueueType parsePersistenceQueueType(String value, PersistenceQueueType fallback) {</span>
<span class="source-line-no">325</span><span id="line-325">    if (value == null || value.isBlank()) {</span>
<span class="source-line-no">326</span><span id="line-326">      return fallback;</span>
<span class="source-line-no">327</span><span id="line-327">    }</span>
<span class="source-line-no">328</span><span id="line-328">    return PersistenceQueueType.fromString(value.trim());</span>
<span class="source-line-no">329</span><span id="line-329">  }</span>
<span class="source-line-no">330</span><span id="line-330"></span>
<span class="source-line-no">331</span><span id="line-331">  private static void denyDangerousBpf(String expression) {</span>
<span class="source-line-no">332</span><span id="line-332">    if (expression.contains(";") || expression.contains("`")) {</span>
<span class="source-line-no">333</span><span id="line-333">      throw new IllegalArgumentException("bpf expression contains disallowed characters");</span>
<span class="source-line-no">334</span><span id="line-334">    }</span>
<span class="source-line-no">335</span><span id="line-335">  }</span>
<span class="source-line-no">336</span><span id="line-336"></span>
<span class="source-line-no">337</span><span id="line-337">  private static int parseBoundedInt(</span>
<span class="source-line-no">338</span><span id="line-338">      Map&lt;String, String&gt; kv, String key, int defaultValue, int min, int max) {</span>
<span class="source-line-no">339</span><span id="line-339">    String raw = kv.get(key);</span>
<span class="source-line-no">340</span><span id="line-340">    if (raw == null || raw.isBlank()) {</span>
<span class="source-line-no">341</span><span id="line-341">      Numbers.requireRange(key, defaultValue, min, max);</span>
<span class="source-line-no">342</span><span id="line-342">      return defaultValue;</span>
<span class="source-line-no">343</span><span id="line-343">    }</span>
<span class="source-line-no">344</span><span id="line-344">    try {</span>
<span class="source-line-no">345</span><span id="line-345">      int parsed = Integer.parseInt(raw.trim());</span>
<span class="source-line-no">346</span><span id="line-346">      Numbers.requireRange(key, parsed, min, max);</span>
<span class="source-line-no">347</span><span id="line-347">      return parsed;</span>
<span class="source-line-no">348</span><span id="line-348">    } catch (NumberFormatException ex) {</span>
<span class="source-line-no">349</span><span id="line-349">      throw new IllegalArgumentException(key + " must be an integer between " + min + " and " + max, ex);</span>
<span class="source-line-no">350</span><span id="line-350">    }</span>
<span class="source-line-no">351</span><span id="line-351">  }</span>
<span class="source-line-no">352</span><span id="line-352"></span>
<span class="source-line-no">353</span><span id="line-353">  private static boolean parseBoolean(String value, boolean fallback) {</span>
<span class="source-line-no">354</span><span id="line-354">    if (value == null || value.isBlank()) {</span>
<span class="source-line-no">355</span><span id="line-355">      return fallback;</span>
<span class="source-line-no">356</span><span id="line-356">    }</span>
<span class="source-line-no">357</span><span id="line-357">    return Boolean.parseBoolean(value.trim());</span>
<span class="source-line-no">358</span><span id="line-358">  }</span>
<span class="source-line-no">359</span><span id="line-359"></span>
<span class="source-line-no">360</span><span id="line-360">  private static Path parsePath(String name, String value) {</span>
<span class="source-line-no">361</span><span id="line-361">    try {</span>
<span class="source-line-no">362</span><span id="line-362">      return Path.of(Strings.requireNonBlank(name, value)).toAbsolutePath().normalize();</span>
<span class="source-line-no">363</span><span id="line-363">    } catch (InvalidPathException ex) {</span>
<span class="source-line-no">364</span><span id="line-364">      throw new IllegalArgumentException(name + " is not a valid path: " + value, ex);</span>
<span class="source-line-no">365</span><span id="line-365">    }</span>
<span class="source-line-no">366</span><span id="line-366">  }</span>
<span class="source-line-no">367</span><span id="line-367"></span>
<span class="source-line-no">368</span><span id="line-368">  private static java.util.Optional&lt;Path&gt; parseOptionalPath(String name, String value) {</span>
<span class="source-line-no">369</span><span id="line-369">    if (value == null || value.isBlank()) {</span>
<span class="source-line-no">370</span><span id="line-370">      return java.util.Optional.empty();</span>
<span class="source-line-no">371</span><span id="line-371">    }</span>
<span class="source-line-no">372</span><span id="line-372">    return java.util.Optional.of(parsePath(name, value));</span>
<span class="source-line-no">373</span><span id="line-373">  }</span>
<span class="source-line-no">374</span><span id="line-374">  private static String firstNonBlank(Map&lt;String, String&gt; map, String... keys) {</span>
<span class="source-line-no">375</span><span id="line-375">    for (String key : keys) {</span>
<span class="source-line-no">376</span><span id="line-376">      String val = map.get(key);</span>
<span class="source-line-no">377</span><span id="line-377">      if (val != null &amp;&amp; !val.isBlank()) {</span>
<span class="source-line-no">378</span><span id="line-378">        return val;</span>
<span class="source-line-no">379</span><span id="line-379">      }</span>
<span class="source-line-no">380</span><span id="line-380">    }</span>
<span class="source-line-no">381</span><span id="line-381">    return null;</span>
<span class="source-line-no">382</span><span id="line-382">  }</span>
<span class="source-line-no">383</span><span id="line-383"></span>
<span class="source-line-no">384</span><span id="line-384">  private static Path normalizePath(String name, Path path) {</span>
<span class="source-line-no">385</span><span id="line-385">    if (path == null) {</span>
<span class="source-line-no">386</span><span id="line-386">      throw new IllegalArgumentException(name + " must not be null");</span>
<span class="source-line-no">387</span><span id="line-387">    }</span>
<span class="source-line-no">388</span><span id="line-388">    String raw = path.toString();</span>
<span class="source-line-no">389</span><span id="line-389">    if (raw.indexOf('\0') &gt;= 0) {</span>
<span class="source-line-no">390</span><span id="line-390">      throw new IllegalArgumentException(name + " must not contain null bytes");</span>
<span class="source-line-no">391</span><span id="line-391">    }</span>
<span class="source-line-no">392</span><span id="line-392">    return path.toAbsolutePath().normalize();</span>
<span class="source-line-no">393</span><span id="line-393">  }</span>
<span class="source-line-no">394</span><span id="line-394"></span>
<span class="source-line-no">395</span><span id="line-395">  private static Path defaultBaseDirectory() {</span>
<span class="source-line-no">396</span><span id="line-396">    String userHome = System.getProperty("user.home", ".");</span>
<span class="source-line-no">397</span><span id="line-397">    return Path.of(userHome, ".radar", "out");</span>
<span class="source-line-no">398</span><span id="line-398">  }</span>
<span class="source-line-no">399</span><span id="line-399"></span>
<span class="source-line-no">400</span><span id="line-400">  /** Queue implementations available for live persistence hand-off. */</span>
<span class="source-line-no">401</span><span id="line-401">  public enum PersistenceQueueType {</span>
<span class="source-line-no">402</span><span id="line-402">    ARRAY,</span>
<span class="source-line-no">403</span><span id="line-403">    LINKED;</span>
<span class="source-line-no">404</span><span id="line-404"></span>
<span class="source-line-no">405</span><span id="line-405">    static PersistenceQueueType fromString(String value) {</span>
<span class="source-line-no">406</span><span id="line-406">      String normalized = value.toLowerCase(Locale.ROOT);</span>
<span class="source-line-no">407</span><span id="line-407">      return switch (normalized) {</span>
<span class="source-line-no">408</span><span id="line-408">        case "array", "arrayblockingqueue", "array-queue" -&gt; ARRAY;</span>
<span class="source-line-no">409</span><span id="line-409">        case "linked", "linkedblockingqueue", "linked-queue" -&gt; LINKED;</span>
<span class="source-line-no">410</span><span id="line-410">        default -&gt; throw new IllegalArgumentException(</span>
<span class="source-line-no">411</span><span id="line-411">            "persistQueueType must be one of ARRAY or LINKED (was " + value + ")");</span>
<span class="source-line-no">412</span><span id="line-412">      };</span>
<span class="source-line-no">413</span><span id="line-413">    }</span>
<span class="source-line-no">414</span><span id="line-414">  }</span>
<span class="source-line-no">415</span><span id="line-415">}</span>
<span class="source-line-no">416</span><span id="line-416"></span>
<span class="source-line-no">417</span><span id="line-417"></span>
<span class="source-line-no">418</span><span id="line-418"></span>
<span class="source-line-no">419</span><span id="line-419"></span>
<span class="source-line-no">420</span><span id="line-420"></span>




























































</pre>
</div>
</main>
</body>
</html>
