package ca.gc.cra.radar.infrastructure.poster;import static org.junit.jupiter.api.Assertions.*;import ca.gc.cra.radar.config.PosterConfig.DecodeMode;import ca.gc.cra.radar.domain.protocol.ProtocolId;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Path;import java.util.List;import org.junit.jupiter.api.Test;class SegmentPosterProcessorTest {  @Test  void processHttpPairsDecodesTransferAndContentEncodings() throws Exception {    Path input = PosterFixtures.tempDir("poster-http-in");    Path output = PosterFixtures.tempDir("poster-http-out");    try {      Path reqHeaders = input.resolve("req-headers.bin");      Path reqBody = input.resolve("req-body.bin");      Path rspHeaders = input.resolve("rsp-headers.bin");      Path rspBody = input.resolve("rsp-body.bin");      PosterFixtures.write(reqHeaders, PosterFixtures.ascii("GET /demo HTTP/1.1\r\nHost: example\r\nTransfer-Encoding: chunked\r\n\r\n"));      PosterFixtures.write(reqBody, PosterFixtures.ascii("3\r\nhi!\r\n0\r\n\r\n"));      PosterFixtures.write(rspHeaders, PosterFixtures.ascii("HTTP/1.1 200 OK\r\nContent-Encoding: gzip\r\n\r\n"));      PosterFixtures.write(rspBody, PosterFixtures.gzip(PosterFixtures.ascii("hello world")));      String reqLine = PosterFixtures.httpIndexEntry(          "txn:1",          "REQ",          1_000L,          1_500L,          "10.0.0.1:1234",          "10.0.0.2:80",          "GET /demo HTTP/1.1",          reqHeaders.getFileName().toString(),          Files.size(reqHeaders),          reqBody.getFileName().toString(),          Files.size(reqBody));      String rspLine = PosterFixtures.httpIndexEntry(          "txn:1",          "RSP",          2_000L,          2_500L,          "10.0.0.2:80",          "10.0.0.1:1234",          "HTTP/1.1 200 OK",          rspHeaders.getFileName().toString(),          Files.size(rspHeaders),          rspBody.getFileName().toString(),          Files.size(rspBody));      Files.writeString(input.resolve("index-000.ndjson"), reqLine + System.lineSeparator() + rspLine + System.lineSeparator(), StandardCharsets.UTF_8);      new SegmentPosterProcessor().process(input, output, ProtocolId.HTTP, DecodeMode.ALL);      List<Path> files;      try (var stream = Files.list(output)) {        files = stream.filter(Files::isRegularFile).toList();      }      assertEquals(1, files.size(), "expected single HTTP poster output");      Path poster = files.get(0);      assertEquals("1000_txn_1.http", poster.getFileName().toString());      String content = Files.readString(poster, StandardCharsets.UTF_8);      assertTrue(content.contains("=== HTTP REQUEST ==="));      assertTrue(content.contains("=== HTTP RESPONSE ==="));      assertFalse(content.contains("Transfer-Encoding"), () -> "unexpected transfer header: " + content);      assertFalse(content.contains("Content-Encoding"), () -> "unexpected encoding header: " + content);      assertTrue(content.contains("hi!"));      assertTrue(content.contains("hello world"));      assertTrue(content.contains("Content-Length: 3"));      assertTrue(content.contains("Content-Length: 11"));    } finally {      PosterFixtures.deleteRecursively(output);      PosterFixtures.deleteRecursively(input);    }  }  @Test  void processHttpLeavesOriginalBodyWhenDecodingFails() throws Exception {    Path input = PosterFixtures.tempDir("poster-http-fail-in");    Path output = PosterFixtures.tempDir("poster-http-fail-out");    try {      Path headers = input.resolve("headers.bin");      Path body = input.resolve("body.bin");      PosterFixtures.write(headers, PosterFixtures.ascii("GET /x HTTP/1.1\r\nContent-Encoding: deflate\r\n\r\n"));      PosterFixtures.write(body, PosterFixtures.ascii("not deflated"));      String entry = PosterFixtures.httpIndexEntry(          "tx2",          "REQ",          10L,          20L,          "1.1.1.1:1",          "2.2.2.2:2",          "GET /x HTTP/1.1",          headers.getFileName().toString(),          Files.size(headers),          body.getFileName().toString(),          Files.size(body));      Files.writeString(input.resolve("index-001.ndjson"), entry + System.lineSeparator(), StandardCharsets.UTF_8);      new SegmentPosterProcessor().process(input, output, ProtocolId.HTTP, DecodeMode.ALL);      Path poster;      try (var stream = Files.list(output)) {        poster = stream.findFirst().orElseThrow();      }      String content = Files.readString(poster, StandardCharsets.UTF_8);      assertTrue(content.contains("Content-Encoding: deflate"), () -> "expected encoding header to remain: " + content);      assertTrue(content.contains("not deflated"));    } finally {      PosterFixtures.deleteRecursively(output);      PosterFixtures.deleteRecursively(input);    }  }  @Test  void processWritesBinaryAndEmptyBodyMarkers() throws Exception {    Path input = PosterFixtures.tempDir("poster-binary-in");    Path output = PosterFixtures.tempDir("poster-binary-out");    try {      Path reqHeaders = input.resolve("headers.bin");      Path rspHeaders = input.resolve("rsp-headers.bin");      Path rspBody = input.resolve("rsp-body.bin");      PosterFixtures.write(reqHeaders, PosterFixtures.ascii("GET /bin HTTP/1.1\r\n\r\n"));      PosterFixtures.write(rspHeaders, PosterFixtures.ascii("HTTP/1.1 200 OK\r\n\r\n"));      PosterFixtures.write(rspBody, new byte[] {0x00, 0x0C, 0x20});      String reqEntry = PosterFixtures.httpIndexEntry(          "bin1",          "REQ",          5L,          6L,          "10.0.0.1:1",          "10.0.0.2:2",          "GET /bin HTTP/1.1",          reqHeaders.getFileName().toString(),          Files.size(reqHeaders),          null,          0L);      String rspEntry = PosterFixtures.httpIndexEntry(          "bin1",          "RSP",          7L,          8L,          "10.0.0.2:2",          "10.0.0.1:1",          "HTTP/1.1 200 OK",          rspHeaders.getFileName().toString(),          Files.size(rspHeaders),          rspBody.getFileName().toString(),          Files.size(rspBody));      Files.writeString(          input.resolve("index-001.ndjson"),          reqEntry + System.lineSeparator() + rspEntry + System.lineSeparator(),          StandardCharsets.UTF_8);      new SegmentPosterProcessor().process(input, output, ProtocolId.HTTP, DecodeMode.NONE);      Path poster;      try (var stream = Files.list(output)) {        poster = stream.findFirst().orElseThrow();      }      String content = Files.readString(poster, StandardCharsets.UTF_8);      assertTrue(content.contains("(empty body)"));      assertTrue(content.contains("[binary payload 3 bytes]"));      assertTrue(content.contains("0000: 00 0c 20"));    } finally {      PosterFixtures.deleteRecursively(output);      PosterFixtures.deleteRecursively(input);    }  }  @Test  void processFlushesIncompletePairAndSanitizesUnknownId() throws Exception {    Path input = PosterFixtures.tempDir("poster-partial-in");    Path output = PosterFixtures.tempDir("poster-partial-out");    try {      Path headers = input.resolve("headers.bin");      PosterFixtures.write(headers, PosterFixtures.ascii("GET /only HTTP/1.1\r\n\r\n"));      String entry = PosterFixtures.httpIndexEntry(          "",          "REQ",          123L,          124L,          "a:1",          "b:2",          "GET /only HTTP/1.1",          headers.getFileName().toString(),          Files.size(headers),          null,          0L);      Files.writeString(input.resolve("index-001.ndjson"), entry + System.lineSeparator(), StandardCharsets.UTF_8);      new SegmentPosterProcessor().process(input, output, ProtocolId.HTTP, DecodeMode.NONE);      Path poster;      try (var stream = Files.list(output)) {        poster = stream.findFirst().orElseThrow();      }      assertTrue(poster.getFileName().toString().endsWith("unknown.http"));      String content = Files.readString(poster, StandardCharsets.UTF_8);      assertTrue(content.contains("(no response captured)"));    } finally {      PosterFixtures.deleteRecursively(output);      PosterFixtures.deleteRecursively(input);    }  }  @Test  void processSkipsMalformedAndNonMatchingEntries() throws Exception {    Path input = PosterFixtures.tempDir("poster-skip-in");    Path output = PosterFixtures.tempDir("poster-skip-out");    try {      String malformed = "not json";      String tnEntry = PosterFixtures.tnIndexEntry(          "tn1",          "REQ",          1L,          2L,          "s",          "d",          null,          0L);      Files.writeString(          input.resolve("index-001.ndjson"),          malformed + System.lineSeparator() + tnEntry + System.lineSeparator(),          StandardCharsets.UTF_8);      new SegmentPosterProcessor().process(input, output, ProtocolId.HTTP, DecodeMode.NONE);      try (var stream = Files.list(output)) {        assertTrue(stream.findAny().isEmpty(), "expected no HTTP outputs");      }    } finally {      PosterFixtures.deleteRecursively(output);      PosterFixtures.deleteRecursively(input);    }  }  @Test  void processTn3270PairsWriteHexDump() throws Exception {    Path input = PosterFixtures.tempDir("poster-tn-in");    Path output = PosterFixtures.tempDir("poster-tn-out");    try {      Path reqBody = input.resolve("tn-req.bin");      Path rspBody = input.resolve("tn-rsp.bin");      PosterFixtures.write(reqBody, new byte[] {0x01, 0x02});      PosterFixtures.write(rspBody, new byte[] {(byte) 0xFF});      String reqEntry = PosterFixtures.tnIndexEntry(          "tn-pair",          "REQ",          50L,          51L,          "10.10.10.1:992",          "10.10.10.2:23",          reqBody.getFileName().toString(),          Files.size(reqBody));      String rspEntry = PosterFixtures.tnIndexEntry(          "tn-pair",          "RSP",          60L,          70L,          "10.10.10.2:23",          "10.10.10.1:992",          rspBody.getFileName().toString(),          Files.size(rspBody));      Files.writeString(          input.resolve("index-001.ndjson"),          reqEntry + System.lineSeparator() + rspEntry + System.lineSeparator(),          StandardCharsets.UTF_8);      new SegmentPosterProcessor().process(input, output, ProtocolId.TN3270, DecodeMode.NONE);      Path poster;      try (var stream = Files.list(output)) {        poster = stream.filter(p -> p.getFileName().toString().endsWith(".tn3270.txt")).findFirst().orElseThrow();      }      String content = Files.readString(poster, StandardCharsets.UTF_8);      assertTrue(content.contains("=== TN3270 REQUEST ==="));      assertTrue(content.contains("=== TN3270 RESPONSE ==="));      assertTrue(content.contains("0000: 01 02"));      assertTrue(content.contains("0000: ff"));    } finally {      PosterFixtures.deleteRecursively(output);      PosterFixtures.deleteRecursively(input);    }  }}
